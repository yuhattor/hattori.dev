---
title: "GitHub Copilotによる責任あるAIペアプログラミング"
subtitle: "GitHub Copilotは開発者の生産性を向上させますが、責任を持って使用するには、開発者とDevSecOpsの優れたプラクティスが必要です。"
englishsubtitle: "GitHub Copilot boosts developer productivity, but using it responsibly still requires good developer and DevSecOps practices."
englishtitle: "Responsible AI pair programming with GitHub Copilot"
date: "2023-02-22"
cardurl: "https://github.blog/2023-02-22-responsible-ai-pair-programming-with-github-copilot/"
author: "Colin Dembovsky"
description: " GitHub Copilot is like something out of a sci-fi movie—an AI pair programmer that seems capable of reading your mind as you code. GitHub Copilot uses OpenAI Codex , trained on billions of lines of public code, to suggest code and even entire functions in real-time in a developer’s integrated development editor (IDE). Using GitHub Copilot boosts developer productivity, but it is not a silver bullet, nor a replacement for good coding practices and DevSecOps processes. In this post we look at how to think about GitHub Copilot to use it effectively and responsibly.  AI-paired programming—the next frontier  Computers do not understand programming languages—they understand low-level commands. However, most developers today are not coding in low-level commands or assembler code; they use higher-level abstractions that make programming easier and far more productive. AI models that assist developers are well positioned to become ubiquitous, much like how third and fourth generation (3GL and 4GL) programming languages have all but superseded low-level programming, especially for business applications.  GitHub Copilot is not the only AI-powered model in the news. You may have heard of ChatGPT —a model created by OpenAI that can answer natural language questions and assist with tasks like emails, and even write code based on prompts. OpenAI also created DALLE-2 , which can create realist"
coverimage: "https://github.blog/wp-content/uploads/2022/06/Copilot.jpeg?resize=1200%2C630"
category: "Company,editor tools,features"
englishsummary: " AI-generated text and code.  GitHub Copilot uses OpenAI Codex to assist developers with coding tasks and boost productivity, joining the likes of ChatGPT and DALLE-2 in the AI-paired programming space."
summary: "AIが生成するテキストとコード  GitHub Copilotは、OpenAI Codexを使用して開発者のコーディング作業を支援し、生産性を向上させ、ChatGPTやDALLE-2のようなAIとペアリングするプログラミングの領域に加わります。"
---

<p><a href="https://github.com/features/copilot">GitHub Copilot</a>は、SF映画に出てくるようなAIペアプログラマーで、コードを書きながらあなたの心を読み取ることができるようです。GitHub Copilotは、何十億行ものパブリックコードで学習した<a href="https://openai.com/blog/openai-codex/">OpenAI Codexを</a>使用して、開発者の統合開発エディター（IDE）上でリアルタイムにコードや関数全体を提案します。GitHub Copilotを使用すると、開発者の生産性が向上しますが、銀の弾丸ではありませんし、優れたコーディングプラクティスやDevSecOpsプロセスの代わりとなるものではありません。この記事では、GitHub Copilotを効果的かつ責任を持って使用するために、どのように考えるべきかを見ていきます。</p>
<h2 id="ai-paired-programming-the-next-frontier">AIとペアプログラミング-次のフロンティア<a href="#ai-paired-programming-the-next-frontier" class="heading-link pl-2 text-italic text-bold" aria-label="AI-paired programming—the next frontier"></a></h2>
<p>コンピュータはプログラミング言語を理解しませんが、彼らは低レベルのコマンドを理解します。しかし、今日のほとんどの開発者は、低レベルのコマンドやアセンブラコードでコーディングしているわけではなく、プログラミングをより簡単に、より生産的にするための高レベルの抽象化を使っているのです。開発者を支援するAIモデルは、特にビジネスアプリケーションにおいて、第3世代と第4世代のプログラミング言語（3GLと4GL）が低レベルのプログラミングに取って代わったように、ユビキタスになる可能性が高いのです。</p>
<p>GitHub Copilotだけが、話題のAI搭載モデルというわけではありません。<a href="https://openai.com/">OpenAIが</a>開発した<a href="https://openai.com/blog/chatgpt/">ChatGPTは</a>、自然言語による質問に答え、メールなどの作業を支援し、プロンプトに基づいてコードを書くこともできるモデルで、ご存じかもしれません。また、OpenAIは、自然言語の記述に基づいてリアルなアートを作成できる「<a href="https://openai.com/dall-e-2/">DALLE-2</a>」を開発しました。</p>
<p>なぜ、このようなAIを使ったツールが普及しているのでしょうか。その理由のひとつは、タスクの達成<em>方法の</em>詳細からユーザーを引き離し、<em>何を</em>達成しようとしているのかをより明確に考えることができるようにするためです。</p>
<h2 id="theory-building-and-cognitive-load">理論構築と認知負荷<a href="#theory-building-and-cognitive-load" class="heading-link pl-2 text-italic text-bold" aria-label="Theory building and cognitive load"></a></h2>
<p>ピーター・ナウルは『<em>Programming as Theory Building</em>』（1985年）の中で、"プログラムの構築は、プログラマーのチームによるそれの理論の構築と同じである "と書いている。開発者がプログラミングをするとき、彼らは<em>ビジネス上の問題を解決</em>するために理論（あるいはモデル）を実装しようとしているのです。プログラミングが付加する価値は、プログラミングそのものではなく、それが解決する問題にあるのです。</p>
<p>認知負荷とは、あるタスクを完了するために必要なワーキングメモリの量のことである。プログラミングにおける認知負荷は、大きく分けて、内在的なもの（プログラミングの方法を知っている）、外在的なもの（配列の構築、データベースへの項目の追加、APIの呼び出し方法を知っている）、顕在的なもの（ビジネスの問題を解決する方法を知っている）の3種類に分けられる。プログラミングには本質的な知識が必要ですが、本質的な負荷を最大化し、外的な負荷を最小化できる開発者は、より生産性が高いと言えます。</p>
<p>ある開発者がeコマースサイトを設計しているとします。彼らは、商品カタログ、注文、買い物かご、出荷追跡、その他のビジネスの側面をモデル化する必要があります。商品カタログを想像してみましょう。開発者が時間とエネルギーを集中させたいのは、適切な顧客に適切な商品を最も効率的に表示する方法でしょうか、それとも商品リストをデータベースに照会する方法でしょうか？開発者がデータベースへの問い合わせや、バックエンドからフロントエンドへのオブジェクトの受け渡しの仕組みで「ワーキングメモリー」をいっぱいにしているとき、彼らは<em>ビジネスの</em>問題について本当に考えているわけではありません。開発者が考えているのは、どの商品のサブセットを最初に取得するか、あるいは売上を伸ばすために商品の画像をどのように配置するかといった、開発者が解決しようとしている本質的な問題なのです。</p>
<p>GitHub Copilot は、開発者がプログラミングそのものよりもビジネス上の問題 (プログラムの理論) に集中できるようにするためのものです。</p>
<h2 id="context-switching">コンテキストの切り替え<a href="#context-switching" class="heading-link pl-2 text-italic text-bold" aria-label="Context switching"></a></h2>
<p><a href="https://survey.stackoverflow.co/2022/#section-productivity-impacts-daily-time-spent-searching-for-answers-solutions">2022年のStack Overflow開発者調査に</a>よると、調査対象となった開発者の63%が1日に30分以上、問題の答えや解決策を探すのに時間を費やしています（外来認知負荷）。50人の開発者がいるチームの場合、StackOverflowでは、チーム全体で1週間に300時間から650時間の時間が失われると試算しています。</p>
<p>コンテキストの切り替えは、集中力と生産性を高める妨げになることが証明されています。定型的なコードを実装するためにIDEから切り替えてインターネットを検索すると、開発者のフローが妨げられ、フローで過ごす時間が短ければ短いほど、生産性は低下します。私たちのレポート「<a href="https://github.blog/2022-09-07-research-quantifying-github-copilots-impact-on-developer-productivity-and-happiness/?utm_source=github&amp;utm_medium=referral&amp;utm_campaign=&amp;scid=&amp;utm_content=octoverse#figure-summary-of-the-experiment-process-and-results">リサーチ：GitHub Copilotが開発者の生産性と幸福度に与える影響を定量化</a>する」では、Copilotを使用している開発者は、88%生産性が向上し、73%フローに入ったと報告しています。私たちは、JavascriptでWebサーバーを書く95人の開発者を募集し、そのうちの45人にGitHub Copilotを与えました。この45人の開発者は、GitHub Copilotを使用しないグループに比べ、55%速くタスクを完了しました。</p>
<h2 id="github-copilot-to-the-rescue">GitHub Copilot の活用<a href="#github-copilot-to-the-rescue" class="heading-link pl-2 text-italic text-bold" aria-label="GitHub Copilot to the rescue"></a></h2>
<p>上記の課題を理解することで、GitHub Copilot の価値を理解することができます。GitHub Copilot は、開発者が<em>コードそのものよりも</em>、<em>構築している理論について</em>考えることに時間を割けるようにします。あるいは認知的負荷の観点からも。GitHub Copilot は、余計なワーキングメモリーを減らし、開発者がより本質的なビジネス問題に集中できるようにします。解決策や答えを探すためにIDEを常に切り替えるのではなく、GitHub Copilotは開発者の作業中に文脈に沿った解決策を合成し、開発者のフローを維持するのです。</p>
<p>しかし、GitHub Copilotのソリューションが正しく、安全であることをどうやって確認するのでしょうか？一言で言えば、「わからない」のです。開発者が利用する他のウェブサイトやコードリソースと同様に、自動操縦ではなく副操縦士として機能することを意図しています。GitHub Copilot は生産性を高めるために設計されていますが、開発者の代わりをするものではありませんし、コードのスキャン、テスト、検証のための優れた実践やプロセスの代わりをするものでもありません。</p>
<h2 id="github-copilot-in-the-inner-loop">インナーループにおけるGitHub Copilot<a href="#github-copilot-in-the-inner-loop" class="heading-link pl-2 text-italic text-bold" aria-label="GitHub Copilot in the inner loop"></a></h2>
<p>DevSecOpsについて議論するとき、チームはしばしば内側ループと外側ループに言及します。インナーループとは、開発者の開発環境で行われる開発の一部で、開発者はローカル（自分の開発マシンまたは<a href="https://github.com/features/codespaces">コードスペース</a>）でコードをコーディング、実行、デバッグし、ピアコードレビュー（通常は<a href="https://docs.github.com/en/enterprise-cloud@latest/pull-requests/collaborating-with-pull-requests/proposing-changes-to-your-work-with-pull-requests/about-pull-requests">プルリクエストを</a>使用）も行います。<a href="https://github.com/features/security">GitHub Advanced Securityの</a>ようなDevSecOps環境のセキュリティツールは、プルリクエストのセキュリティレビューと予防的セキュリティチェックによってインターループに組み込まれ、開発速度を高く維持しながら脆弱性を防止することができます。アウターループでは、<a href="https://resources.github.com/ci-cd/">継続的インテグレーション／継続的デリバリー</a>（CI/CD）が行われ、<a href="https://github.com/features/actions">GitHub Actionsの</a>ような自動化エンジンを使ってコードのビルド、スキャン、テスト、デプロイを行うために自動化が活用される。</p>
<p>内側のループ（開発環境）では、GitHub Copilot が開発者を支援し、上記で説明したように、開発者が忙しくしているコンテキストに基づいてコードスニペットを合成し、開発者をフロー内にとどめることができるのです。では、GitHub Copilot が自分にとって良いコードを生成しているか悪いコードを生成しているか、開発者はどのようにして知ることができるのでしょうか？まず始めに、GitHub Copilot を使用する開発者は、コーディングしている言語について基本的な理解をしておく必要があります。そうすることで、GitHub Copilot が提案する解決策が有効かどうかを判断しやすくなります。そこから、やはりコードはローカルで実行され、テストされるべきです。そしてもちろん、コードレビューも省略してはいけません。</p>
<h2 id="the-outer-loop">外側のループ<a href="#the-outer-loop" class="heading-link pl-2 text-italic text-bold" aria-label="The outer loop"></a></h2>
<p>外側のループは、GitHub Copilotがコードの作成に協力したかどうかにかかわらず、すべてのコードに適用されるべきです。組織は、GitHub Copilotなしでコードを検証するために現在使っているのと同じプラクティスやプロセスを、GitHub Copilotで合成されたコードに適用すべきです。これらのプラクティスには、自動化されたリンティング、ユニットテスト、<a href="https://github.com/features/security/code">静的アプリケーションセキュリティテスト（SAST）</a>、<a href="https://github.com/features/security/software-supply-chain">ソフトウェア構成分析（SCA）などが</a>あり、<a href="https://github.com/features/security">GitHub Advanced Securityで</a>実現し、<a href="https://github.com/features/actions">GitHub Actionsで</a>自動化することが可能です。理想的には、機能テスト、統合テスト、負荷テスト、侵入テストも実施する必要があります。GitHub Copilot は、これらの実践の必要性を無効にするものではありません。</p>
<h2 id="conclusion">まとめ<a href="#conclusion" class="heading-link pl-2 text-italic text-bold" aria-label="Conclusion"></a></h2>
<p>GitHub Copilotは、開発者がフローを維持し、より生産的になるための素晴らしい生産性向上ツールですが、優れた開発およびDevSecOpsプラクティスに取って代わるものではありません。AIを搭載したツールが普及するにつれ、企業はチームが自信を持ってこれらのツールを活用できるように、開発者とDevSecOpsの優れたプラクティスを確実に実行する必要があります。</p>


